<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>What #[derive(Mul)] generates</title>

    
    <link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<script src="../storage.js"></script>
<noscript>
    <link rel="stylesheet" href="../noscript.css">
</noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <nav class="sidebar">
    <div class="sidebar-menu">&#9776;</div>
    <a href='../derive_more/index.html'>
        <div class='logo-container'><img src='../rust-logo.png' alt='logo'></div>
    </a>
    <p class='location'>Crate derive_more</p>
    <div class="sidebar-elems">
        <a id='all-types' href='all.html'>
            <p>See all derive_more's items</p>
        </a>
        <p class='location'></p>
        <script>
            window.sidebarCurrent = {
                name: 'derive_more',
                ty: 'mod',
                relpath: '../'
            };
        </script>
    </div>
</nav>
<div class="theme-picker">
    <button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button>
    <div id="theme-choices"></div>
</div>
<script src="../theme.js"></script>
<nav class="sub">
    <form class="search-form js-only">
        <div class="search-container">
            <div>
                <select id="crate-search">
                    <option value="All crates">All crates</option>
                </select>
                <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search">
            </div>
            <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a>
        </div>
    </form>
</nav>
<section id="main" class="content">
    <div class='docblock'>


    <h1 class="title">What #[derive(Mul)] generates</h1>
    <nav id="TOC"><ul>
<li><a href="#tuple-structs">1 Tuple structs</a><ul></ul></li>
<li><a href="#regular-structs">2 Regular structs</a><ul></ul></li>
<li><a href="#enums">3 Enums</a><ul></ul></li></ul></nav><p>Deriving <code>Mul</code> is quite different from deriving <code>Add</code>. It is not used to
multiply two structs together. Instead it will normally multipy a struct, which
can have multiple fields, with a single primitive type (e.g. a <code>u64</code>). A new
struct is then created with all the fields from the previous struct multiplied
by this other value.</p>
<p>A simple way of explaining the reasoning behind this difference between <code>Add</code>
and <code>Mul</code> deriving, is looking at arithmetic on meters.
One meter can be added to one meter, to get two meters. Also, one meter times
two would be two meters, but one meter times one meter would be one square meter.
As this second case clearly requires more knowledge about the meaning of the
type in question deriving for this is not implemented.</p>
<p>NOTE: In case you don’t want this behaviour you can add <code>#[mul(forward)]</code>.
This will instead generate a <code>Mul</code> implementation with the same semantics as
<code>Add</code>.</p>
<h1 id="tuple-structs" class="section-header"><a href="#tuple-structs">1 Tuple structs</a></h1>
<p>When deriving for a tuple struct with a single field (i.e. a newtype) like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Mul</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInt</span>(<span class="ident">i32</span>);</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyInt</span>
    <span class="kw">where</span> <span class="ident">i32</span>: <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span>, <span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span>
{
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">MyInt</span>;
    <span class="kw">fn</span> <span class="ident">mul</span>(<span class="self">self</span>, <span class="ident">rhs</span>: <span class="ident">__RhsT</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">MyInt</span> {
        <span class="ident">MyInt</span>(<span class="self">self</span>.<span class="number">0</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>))
    }
}</pre></div>
<p>The behaviour is slightly different for multiple fields, since the right hand
side of the multiplication now needs the <code>Copy</code> trait.
For instance when deriving for a tuple struct with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Mul</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInts</span>(<span class="ident">i32</span>, <span class="ident">i32</span>);</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__RhsT</span>: <span class="ident">::core::marker::Copy</span><span class="op">&gt;</span> <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyInts</span>
    <span class="kw">where</span> <span class="ident">i32</span>: <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span>, <span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span>
{
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">MyInts</span>;
    <span class="kw">fn</span> <span class="ident">mul</span>(<span class="self">self</span>, <span class="ident">rhs</span>: <span class="ident">__RhsT</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">MyInts</span> {
        <span class="ident">MyInts</span>(<span class="self">self</span>.<span class="number">0</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>), <span class="self">self</span>.<span class="number">1</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>))
    }
}</pre></div>
<p>The behaviour is similar with more or less fields.</p>
<h1 id="regular-structs" class="section-header"><a href="#regular-structs">2 Regular structs</a></h1>
<p>When deriving <code>Mul</code> for a regular struct with a single field like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Mul</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point1D</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
}</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Point1D</span>
    <span class="kw">where</span> <span class="ident">i32</span>: <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span>, <span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span>
{
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">Point1D</span>;
    <span class="kw">fn</span> <span class="ident">mul</span>(<span class="self">self</span>, <span class="ident">rhs</span>: <span class="ident">__RhsT</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Point1D</span> {
        <span class="ident">Point1D</span> { <span class="ident">x</span>: <span class="self">self</span>.<span class="ident">x</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>) }
    }
}</pre></div>
<p>The behaviour is again slightly different when deriving for a struct with multiple
fields, because it still needs the <code>Copy</code> as well.
For instance when deriving for a tuple struct with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Mul</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point2D</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
    <span class="ident">y</span>: <span class="ident">i32</span>,
}</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__RhsT</span>: <span class="ident">::core::marker::Copy</span><span class="op">&gt;</span> <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Point2D</span>
    <span class="kw">where</span> <span class="ident">i32</span>: <span class="ident">::core::ops::Mul</span><span class="op">&lt;</span><span class="ident">__RhsT</span>, <span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span>
{
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">Point2D</span>;
    <span class="kw">fn</span> <span class="ident">mul</span>(<span class="self">self</span>, <span class="ident">rhs</span>: <span class="ident">__RhsT</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Point2D</span> {
        <span class="ident">Point2D</span> {
            <span class="ident">x</span>: <span class="self">self</span>.<span class="ident">x</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>),
            <span class="ident">y</span>: <span class="self">self</span>.<span class="ident">y</span>.<span class="ident">mul</span>(<span class="ident">rhs</span>),
        }
    }
}</pre></div>
<h1 id="enums" class="section-header"><a href="#enums">3 Enums</a></h1>
<p>Deriving <code>Mul</code> for enums is not (yet) supported, except when you use
`#[mul(forward)].
Although it shouldn’t be impossible no effort has been put into this yet.</p>

    <!--copied from otput -->
</div>
</section>
<section id="search" class="content hidden"></section>
<section class="footer"></section>
<aside id="help" class="hidden">
    <div>
        <h1 class="hidden">Help</h1>
        <div class="shortcuts">
            <h2>Keyboard Shortcuts</h2>
            <dl><dt><kbd>?</kbd></dt>
                <dd>Show this help dialog</dd><dt><kbd>S</kbd></dt>
                <dd>Focus the search field</dd><dt><kbd>↑</kbd></dt>
                <dd>Move up in search results</dd><dt><kbd>↓</kbd></dt>
                <dd>Move down in search results</dd><dt><kbd>↹</kbd></dt>
                <dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt>
                <dd>Go to active search result</dd><dt><kbd>+</kbd></dt>
                <dd>Expand all sections</dd><dt><kbd>-</kbd></dt>
                <dd>Collapse all sections</dd>
            </dl>
        </div>
        <div class="infos">
            <h2>Search Tricks</h2>
            <p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p>
            <p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p>
            <p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p>
            <p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p>
        </div>
    </div>
</aside>
<script>
    window.rootPath = "../";
    window.currentCrate = "derive_more";
</script>
<script src="../aliases.js"></script>
<script src="../main.js"></script>
<script defer src="../search-index.js"></script>
</body>

</html>


</body>
</html>