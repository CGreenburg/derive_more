<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>What #[derive(Into)] generates</title>

    
    <link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<script src="../storage.js"></script>
<noscript>
    <link rel="stylesheet" href="../noscript.css">
</noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <nav class="sidebar">
    <div class="sidebar-menu">&#9776;</div>
    <a href='../derive_more/index.html'>
        <div class='logo-container'><img src='../rust-logo.png' alt='logo'></div>
    </a>
    <p class='location'>Crate derive_more</p>
    <div class="sidebar-elems">
        <a id='all-types' href='all.html'>
            <p>See all derive_more's items</p>
        </a>
        <p class='location'></p>
        <script>
            window.sidebarCurrent = {
                name: 'derive_more',
                ty: 'mod',
                relpath: '../'
            };
        </script>
    </div>
</nav>
<div class="theme-picker">
    <button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button>
    <div id="theme-choices"></div>
</div>
<script src="../theme.js"></script>
<nav class="sub">
    <form class="search-form js-only">
        <div class="search-container">
            <div>
                <select id="crate-search">
                    <option value="All crates">All crates</option>
                </select>
                <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search">
            </div>
            <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a>
        </div>
    </form>
</nav>
<section id="main" class="content">
    <div class='docblock'>


    <h1 class="title">What #[derive(Into)] generates</h1>
    <nav id="TOC"><ul>
<li><a href="#example-usage">1 Example usage</a><ul></ul></li>
<li><a href="#tuple-structs">2 Tuple structs</a><ul></ul></li>
<li><a href="#regular-structs">3 Regular structs</a><ul></ul></li>
<li><a href="#enums">4 Enums</a><ul></ul></li></ul></nav><p>This derive creates the the exact oposite of <a href="from.html"><code>#[derive(From)]</code></a>.
Instead of allowing you to create a new instance of the struct from the values
it should contain, it allows you to extract the values from the struct.
One thing to note is that this derive doesn’t actually generate an
implementation for the <code>Into</code> trait.
Instead it derives <code>From</code> for the values contained in the struct and thus has an
indirect implementation of <code>Into</code> as recommended by the
<a href="https://doc.rust-lang.org/core/convert/trait.Into.html">docs</a>.</p>
<h1 id="example-usage" class="section-header"><a href="#example-usage">1 Example usage</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="comment">// Allow converting into i32</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInt</span>(<span class="ident">i32</span>);

<span class="comment">// Additionally convert refs to the inner type refs</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">into</span>(<span class="ident">owned</span>, <span class="kw-2">ref</span>, <span class="ident">ref_mut</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInt64</span>(<span class="ident">i64</span>);

<span class="comment">// Specify additional conversions</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">into</span>(<span class="ident">types</span>(<span class="ident">i16</span>, <span class="ident">i32</span>))]</span>
<span class="kw">struct</span> <span class="ident">MyInt8</span>(<span class="ident">i8</span>);

<span class="comment">// Even for ref types</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">into</span>(<span class="ident">owned</span>, <span class="kw-2">ref</span>(<span class="ident">types</span>(<span class="ident">i64</span>)))]</span>
<span class="kw">struct</span> <span class="ident">MyInt64Wrapped</span>(<span class="ident">MyInt64</span>);

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">i32</span>::<span class="ident">from</span>(<span class="ident">MyInt</span>(<span class="number">2</span>)) <span class="op">=</span><span class="op">=</span> <span class="number">2i32</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">i64</span>::<span class="ident">from</span>(<span class="ident">MyInt64</span>(<span class="number">6</span>)) <span class="op">=</span><span class="op">=</span> <span class="number">6i64</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">i64</span><span class="op">&gt;</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">MyInt64</span>(<span class="number">6</span>)) <span class="op">=</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">6i64</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">i64</span><span class="op">&gt;</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">MyInt64</span>(<span class="number">6</span>)) <span class="op">=</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">6i64</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">i8</span>::<span class="ident">from</span>(<span class="ident">MyInt8</span>(<span class="number">7</span>)) <span class="op">=</span><span class="op">=</span> <span class="number">7i8</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">i16</span>::<span class="ident">from</span>(<span class="ident">MyInt8</span>(<span class="number">7</span>)) <span class="op">=</span><span class="op">=</span> <span class="number">7i16</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">i32</span>::<span class="ident">from</span>(<span class="ident">MyInt8</span>(<span class="number">7</span>)) <span class="op">=</span><span class="op">=</span> <span class="number">7i32</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">MyInt64</span>::<span class="ident">from</span>(<span class="ident">MyInt64Wrapped</span>(<span class="ident">MyInt64</span>(<span class="number">1</span>))) <span class="op">=</span><span class="op">=</span> <span class="ident">MyInt64</span>(<span class="number">1</span>));
    <span class="macro">assert</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">MyInt64</span><span class="op">&gt;</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">MyInt64Wrapped</span>(<span class="ident">MyInt64</span>(<span class="number">1</span>))) <span class="op">=</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">MyInt64</span>(<span class="number">1</span>));
    <span class="macro">assert</span><span class="macro">!</span>(<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">i64</span><span class="op">&gt;</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">MyInt64Wrapped</span>(<span class="ident">MyInt64</span>(<span class="number">1</span>))) <span class="op">=</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">1i64</span>);
}</pre></div>
<h1 id="tuple-structs" class="section-header"><a href="#tuple-structs">2 Tuple structs</a></h1>
<p>When deriving <code>Into</code> for a tuple struct with a single field (i.e. a newtype) like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInt</span>(<span class="ident">i32</span>);</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> ::<span class="ident">core</span>::<span class="ident">convert</span>::<span class="ident">From</span><span class="op">&lt;</span><span class="ident">MyInt</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">i32</span>) {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">original</span>: <span class="ident">MyInt</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">i32</span>) {
        (<span class="ident">original</span>.<span class="number">0</span>)
    }
}</pre></div>
<p>The behaviour is a bit different when deriving for a struct with multiple
fields, since it returns a tuple. For instance when deriving for a tuple struct
with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyInts</span>(<span class="ident">i32</span>, <span class="ident">i32</span>);</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> ::<span class="ident">core</span>::<span class="ident">convert</span>::<span class="ident">From</span><span class="op">&lt;</span><span class="ident">MyInts</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">i32</span>, <span class="ident">i32</span>) {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">original</span>: <span class="ident">MyInts</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">i32</span>, <span class="ident">i32</span>) {
        (<span class="ident">original</span>.<span class="number">0</span>, <span class="ident">original</span>.<span class="number">1</span>)
    }
}</pre></div>
<h1 id="regular-structs" class="section-header"><a href="#regular-structs">3 Regular structs</a></h1>
<p>For regular structs almost the same code is generated as for tuple structs
except in the way the field values are assigned to the new struct.
When deriving for a regular struct with a single field like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point1D</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
}</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> ::<span class="ident">core</span>::<span class="ident">convert</span>::<span class="ident">From</span><span class="op">&lt;</span><span class="ident">Point1D</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">i32</span>) {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">original</span>: <span class="ident">Point1D</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">i32</span>) {
        (<span class="ident">original</span>.<span class="ident">x</span>)
    }
}</pre></div>
<p>The behaviour is again a bit different when deriving for a struct with multiple
fields, because this also returns a tuple. For instance when deriving for a
tuple struct with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Into</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point2D</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
    <span class="ident">y</span>: <span class="ident">i32</span>,
}
</pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">impl</span> ::<span class="ident">core</span>::<span class="ident">convert</span>::<span class="ident">From</span><span class="op">&lt;</span><span class="ident">Point2D</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">i32</span>, <span class="ident">i32</span>) {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">original</span>: <span class="ident">Point2D</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">i32</span>, <span class="ident">i32</span>) {
        (<span class="ident">original</span>.<span class="ident">x</span>, <span class="ident">original</span>.<span class="ident">y</span>)
    }
}</pre></div>
<h1 id="enums" class="section-header"><a href="#enums">4 Enums</a></h1>
<p>Deriving <code>Into</code> for enums is not supported as it would not always be successful.
This is what the currently unstable
<a href="https://doc.rust-lang.org/core/convert/trait.TryInto.html"><code>TryInto</code></a> should be
used for, which is currently not supported by this library.</p>

    <!--copied from otput -->
</div>
</section>
<section id="search" class="content hidden"></section>
<section class="footer"></section>
<aside id="help" class="hidden">
    <div>
        <h1 class="hidden">Help</h1>
        <div class="shortcuts">
            <h2>Keyboard Shortcuts</h2>
            <dl><dt><kbd>?</kbd></dt>
                <dd>Show this help dialog</dd><dt><kbd>S</kbd></dt>
                <dd>Focus the search field</dd><dt><kbd>↑</kbd></dt>
                <dd>Move up in search results</dd><dt><kbd>↓</kbd></dt>
                <dd>Move down in search results</dd><dt><kbd>↹</kbd></dt>
                <dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt>
                <dd>Go to active search result</dd><dt><kbd>+</kbd></dt>
                <dd>Expand all sections</dd><dt><kbd>-</kbd></dt>
                <dd>Collapse all sections</dd>
            </dl>
        </div>
        <div class="infos">
            <h2>Search Tricks</h2>
            <p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p>
            <p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p>
            <p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p>
            <p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p>
        </div>
    </div>
</aside>
<script>
    window.rootPath = "../";
    window.currentCrate = "derive_more";
</script>
<script src="../aliases.js"></script>
<script src="../main.js"></script>
<script defer src="../search-index.js"></script>
</body>

</html>


</body>
</html>